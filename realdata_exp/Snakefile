configfile: "config.yml"

import os
from os.path import join as pjoin

wdir = os.getcwd()

root = config["root"]
samples = config["samples"]
contigs = config["assemblies"]
ref = pjoin(root, config["ref"])
kvars = pjoin(root, config["vcf"])

"""
snakeroot
|-- CHS-PUR-YRI.assemblies.pangenome_hg38.20200508.all_variants.genotypes.vcf.gz
|-- CHS-PUR-YRI.assemblies.pangenome_hg38.20200508.all_variants.genotypes.vcf.gz.tbi
|-- HG00733_assembly1.fa
|-- HG00733_assembly2.fa
|-- HG00733.fq
|-- hg38.chroms.fa
|-- g38.chroms.fa.fai
|-- NA19240_assembly1.fa
|-- NA19240_assembly2.fa
'-- NA19240.fq
"""

min_ab = 5
max_l = 500

pp = "pp"
step1 = "step1"
step2 = "step2"

rule run:
    input:
        # STEP 1
        pjoin(root, step1, f"sspecific.minab_{min_ab}.maxl_{max_l}.{samples[0]}.bam"),
        pjoin(root, step1, f"sspecific.minab_{min_ab}.maxl_{max_l}.{samples[1]}.bam"),
        # STEP 2
        pjoin(root, step2, f"sspecific.minab_{min_ab}.maxl_{max_l}.{samples[1]}.bam")

rule nthits:
    input:
        sample = pjoin(root, "{sample}.fq")
    output:
        bf = pjoin(root, pp, "{sample}_nt_k31.bf")
    params:
        out_prefix = pjoin(root, pp, "{sample}_nt")
    log:
        time = pjoin(root, pp, "{sample}_nthits.time"),
        out = pjoin(root, pp, "{sample}_nthits.log")
    threads: 2
    shell:
        """
        /usr/bin/time -vo {log.time} nthits -t {threads} -k 31 -c 2 -b 36 --outbloom -p {params.out_prefix} {input.sample} &> {log.out}
        """

rule ntedits:
    input:
        sample = pjoin(root, "{sample}.fq"),
        bf = pjoin(root, pp, "{sample}_nt_k31.bf")
    output:
        out_prefix = pjoin(root, pp, "{sample}_nt_edited.fa")
    params:
        out_prefix = pjoin(root, pp, "{sample}_nt")
    log:
        time = pjoin(root, pp, "{sample}_ntedit.time"),
        out = pjoin(root, pp, "{sample}_ntedit.log")
    threads : 2
    shell:
        """
        /usr/bin/time -vo {log.time} ntedit -t {threads} -f {input.sample} -r {input.bf} -b {params.out_prefix} &> {log.out}
        """

rule fa2fq:
    input:
        "{fpath}.fa"
    output:
        "{fpath}.fq"
    threads: 1
    shell:
        """
        reformat.sh in={input} out={output} qfake=93
        """

rule pp_index:
    input:
        pjoin(root, pp, f"{samples[0]}_nt_edited.fq")
    output:
        pjoin(root, pp, f"{samples[0]}_nt_edited.fq.fmd")
    params:
        bin = pjoin(wdir, "..", "main")
    threads: 4
    log:
        time = pjoin(root, pp, f"index.time"),
        out = pjoin(root, pp, f"index.log")
    shell:
        """
        /usr/bin/time -vo {log.time} {params.bin} index {input} > {output} 2> {log.out}
        """

rule pp_search:
    input:
        index = pjoin(root, pp, f"{samples[0]}_nt_edited.fq.fmd"),
        sample = pjoin(root, pp, f"{samples[1]}_nt_edited.fq")
    output:
        directory(pjoin(root, pp, "sspecific"))
    params:
        bin = pjoin(wdir, "..", "main")
    threads: 2
    log:
        time = pjoin(root, pp, "search.time"),
        out = pjoin(root, pp, "search.log")
    shell:
        """
        mkdir -p {output}
        pushd {output}  &> /dev/null
        /usr/bin/time -vo {log.time} {params.bin} sf3 {input.index} {input.sample} {threads} &> {log.out}
        popd &> /dev/null
        """

rule aggregate:
    input:
        indir = pjoin(root, pp, "sspecific")
    output:
        fq = pjoin(root, pp, "sspecific.fq")
    threads: 1
    shell:
        """
        ./scripts/aggregate {input.indir} > {output.fq}
        """

rule filter:
    input:
        pjoin(root, pp, "sspecific.fq")
    output:
        pjoin(root, pp, f"sspecific.minab_{min_ab}.maxl_{max_l}.fq")
    params:
        ab = min_ab,
        l = max_l
    threads: 1
    shell:
        """
        ./scripts/filter la {input} {params.ab} {params.l} > {output}
        """

### STEP 1: mapping to assemblies ###
rule combine_assemblies:
    input:
        fa1 = pjoin(root, "{sample}_assembly1.fa"),
        fa2 = pjoin(root, "{sample}_assembly2.fa")
    output:
        pjoin(root, step1, "{sample}_assembly.fa")
    shell:
        """
        cat {input.fa1} {input.fa2} | reformat.sh in=stdin.fa out={output} uniquenames=t
        """

rule bbmap_index_1:
    input:
        pjoin(root, step1, "{sample}_assembly.fa")
    output:
        directory(pjoin(root, step1, "{sample}_assembly.bbmapindex"))
    threads: 4
    log:
        time = pjoin(root, step1, "{sample}_assembly.bbmapindex.time"),
        out= pjoin(root, step1, "{sample}_assembly.bbmapindex.log")
    shell:
        """
        /usr/bin/time -vo {log.time} bbmap.sh -Xmx10g threads={threads} k=11 usequality=f ref={input} path={output} &> {log.out}
        """

rule bbmap_align_1:
    input:
        index = pjoin(root, step1, "{sample}_assembly.bbmapindex"),
        fq = pjoin(root, pp, "sspecific.minab_{min_ab}.maxl_{max_l}.fq")
    output:
        sam = pjoin(root, step1, "sspecific.minab_{min_ab}.maxl_{max_l}.{sample}.sam")
    threads: 4
    log:
        time = pjoin(root, step1, "sspecific.minab_{min_ab}.maxl_{max_l}.{sample}.time"),
        out = pjoin(root, step1, "sspecific.minab_{min_ab}.maxl_{max_l}.{sample}.log")
    shell:
        """
        /usr/bin/time -vo {log.time} bbmap.sh -Xmx10g threads={threads} k=11 usequality=f idtag=t path={input.index} in={input.fq} outm={output.sam} &> {log.out}
        """

rule sam2bam:
    input:
        sam = "{fpath}.sam"
    output:
        bam = "{fpath}.bam",
        bai = "{fpath}.bam.bai"
    threads: 2
    shell:
        """
        samtools view -bS {input.sam} | samtools sort > {output.bam}
        samtools index {output.bam}
        """

### STEP 2: mapping to haplotypes + checking overlaps with known variants ###
rule build_haplotype:
    input:
        fa = ref,
        vcf = kvars
    output:
        fa = pjoin(root, step2, "{sample}.hap{h}.fa")
    threads: 1
    shell:
        """
        bcftools consensus -s {wildcards.sample} -H {wildcards.h} -f {input.fa} {input.vcf} > {output.fa}
        """

rule combine_haplotypes:
    input:
        fa1 = pjoin(root, step2, "{sample}.hap1.fa"),
        fa2 = pjoin(root, step2, "{sample}.hap2.fa")
    output:
        fa = pjoin(root, step2, "{sample}_haplotypes.fa")
    threads: 1
    shell:
        """
        cat {input.fa1} {input.fa2} | reformat.sh in=stdin.fa out={output} uniquenames=t
        """

rule bbmap_index_2:
    input:
        pjoin(root, step2, "{sample}_haplotypes.fa")
    output:
        directory(pjoin(root, step2, "{sample}_haplotypes.bbmapindex"))
    threads: 4
    log:
        time = pjoin(root, step2, "{sample}_haplotypes.bbmapindex.time"),
        out= pjoin(root, step2, "{sample}_haplotypes.bbmapindex.log")
    shell:
        """
        /usr/bin/time -vo {log.time} bbmap.sh -Xmx10g threads={threads} k=11 usequality=f ref={input} path={output} &> {log.out}
        """

rule bbmap_align_2:
    input:
        index = pjoin(root, step2, "{sample}_haplotypes.bbmapindex"),
        fq = pjoin(root, pp, "sspecific.minab_{min_ab}.maxl_{max_l}.fq")
    output:
        sam = pjoin(root, step2, "sspecific.minab_{min_ab}.maxl_{max_l}.{sample}.sam")
    threads: 4
    log:
        time = pjoin(root, step2, "sspecific.minab_{min_ab}.maxl_{max_l}.{sample}.time"),
        out = pjoin(root, step2, "sspecific.minab_{min_ab}.maxl_{max_l}.{sample}.log")
    shell:
        """
        /usr/bin/time -vo {log.time} bbmap.sh -Xmx10g threads={threads} k=11 usequality=f idtag=t path={input.index} in={input.fq} outm={output.sam} &> {log.out}
        """

rule bam2bed:
    input:
        "{fpath}.bam"
    output:
        "{fpath}.bam.bed"
    shell:
        """
        bedtools bamtobed -i {input} > {output}
        """

rule vcf2haplobeds:
    input:
        vcf = kvars
    output:
        pjoin(root, step2, f"{samples[1]}_uniquevars_1.bed"),
        pjoin(root, step2, f"{samples[1]}_uniquevars_2.bed")
    params:
        sample1 = samples[1],
        sample2 = samples[0],
        out_prefix = pjoin(root, step2, f"{samples[1]}_uniquevars")
    shell:
        """
        python3 scripts/vcf2haplobeds.py {input.vcf} {params.sample1} {params.sample2} {params.out_prefix}
        """

# rule intersect_beds:
#     input:
#         aligns = pjoin(root, step2, "sspecific.minab_{min_ab}.maxl_{max_l}.{sample}.bam.bed"),
#         vars1 = pjoin(root, step2, f"{samples[1]_uniquevars_1.bed"),
#         vars2 = pjoin(root, step2, f"{samples[1]_uniquevars_2.bed")
#     output:
#         o1 = pjoin(root, step2, "bed1_vs_bam.bed"),
#         o2 = pjoin(root, step2, "bed2_vs_bam.bed"),
#         # ...
#     shell:
#         """
#         bedtools intersect -c -a -b
#         """
